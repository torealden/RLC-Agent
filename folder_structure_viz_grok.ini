import argparse
import json
import re
import sys

def parse_tree(text):
    lines = text.split('\n')
    # Find minimum indentation
    indents = [len(line) - len(line.lstrip()) for line in lines if line.strip()]
    min_indent = min(indents) if indents else 0
    root = None
    stack = []
    for line in lines:
        if not line.strip() or 'Folder Structure' in line:
            continue
        # Strip minimum indent and rstrip
        line = line[min_indent:].rstrip()
        # Match prefix and item
        match = re.match(r'^([│├└─ ]*)(\S+.*)$', line, re.UNICODE)
        if not match:
            continue
        prefix, item = match.groups()
        # Calculate level based on prefix length (each level adds 4 chars)
        level = len(prefix) // 4 if prefix else 0
        # Parse item: name and comment
        if '#' in item:
            parts = item.split('#', 1)
            name = parts[0].strip()
            comment = parts[1].strip()
        else:
            name = item.strip()
            comment = ''
        # Determine type
        node_type = 'folder' if name.endswith('/') else 'file'
        name = name.rstrip('/')
        node = {'name': name, 'type': node_type, 'comment': comment, 'children': []}
        # Adjust stack to current level
        while len(stack) > level:
            stack.pop()
        if len(stack) == 0:
            root = node
        else:
            stack[-1]['children'].append(node)
        if node_type == 'folder':
            stack.append(node)
    return root

def generate_html(root):
    data_json = json.dumps(root)
    html_content = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Folder Structure Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {{ margin: 0; }}
        svg {{ width: 100vw; height: 100vh; }}
    </style>
</head>
<body>
    <div id="viz"></div>
    <script>
        const data = {data_json};
        const width = 1200;
        const radius = width / 2;

        const tree = d3.cluster()
            .size([2 * Math.PI, radius - 100]);

        const hierarchy = d3.hierarchy(data)
            .sort((a, b) => d3.ascending(a.data.name, b.data.name));

        const root = tree(hierarchy);

        const svg = d3.select("#viz").append("svg")
            .attr("width", width)
            .attr("height", width)
            .attr("viewBox", [-radius, -radius, width, width])
            .attr("style", "max-width: 100%; height: auto; font: 10px sans-serif;");

        const g = svg.append("g");

        g.append("g")
            .attr("fill", "none")
            .attr("stroke", "#555")
            .attr("stroke-opacity", 0.4)
            .attr("stroke-width", 1.5)
          .selectAll("path")
          .data(root.links())
          .join("path")
            .attr("d", d3.linkRadial()
                .angle(d => d.x)
                .radius(d => d.y));

        const node = g.append("g")
            .selectAll("g")
          .data(root.descendants())
          .join("g")
            .attr("transform", d => `
              rotate(${{d.x * 180 / Math.PI - 90}})
              translate(${{d.y}},0)
            `);

        node.append("circle")
            .attr("fill", d => d.children ? "#1f77b4" : "#2ca02c")  // Blue for folders, green for files
            .attr("r", 3.5);

        node.append("text")
            .attr("dy", "0.31em")
            .attr("x", d => d.x < Math.PI === !d.children ? 6 : -6)
            .attr("text-anchor", d => d.x < Math.PI === !d.children ? "start" : "end")
            .attr("transform", d => d.x >= Math.PI ? "rotate(180)" : null)
            .text(d => d.data.name)
          .clone(true).lower()
            .attr("stroke-linejoin", "round")
            .attr("stroke-width", 3)
            .attr("stroke", "white");

        node.append("title")
            .text(d => d.data.comment ? d.data.comment : d.data.name);

        // Add zoom and pan
        svg.call(d3.zoom()
            .extent([[0, 0], [width, width]])
            .scaleExtent([0.5, 8])
            .on("zoom", zoomed));

        function zoomed(event) {{
            g.attr("transform", event.transform);
        }}
    </script>
</body>
</html>
    """
    return html_content

def main():
    parser = argparse.ArgumentParser(description="Visualize folder structure as D3 radial cluster tree.")
    parser.add_argument('--in', dest='input_file', help='Path to input tree.txt file')
    parser.add_argument('--out', default='output.html', help='Path to output file (e.g., viz.html)')
    args = parser.parse_args()

    if args.input_file:
        with open(args.input_file, 'r', encoding='utf-8') as f:
            text = f.read()
    else:
        text = """
Folder Structure
  RLC-Agent/
  │
  ├── README.md                      # Project overview & quick start
  ├── LLM_SETUP_PLAN.md             # Setup guide (keep at root)
  ├── requirements.txt
  ├── .env                          # Single source of credentials
  ├── .env.example
  ├── .gitignore
  │
  ├── src/                          # ALL application code
  │   ├── main.py                   # CLI entry point
  │   ├── agents/                   # AI agent implementations
  │   │   ├── core/                 # Master, memory, verification agents
  │   │   ├── collectors/           # Data collection agents (consolidate)
  │   │   ├── analysis/             # Fundamental, price, spread analyzers
  │   │   ├── reporting/            # Report generation agents
  │   │   └── integration/          # Email, calendar, Notion agents
  │   ├── orchestrators/            # Workflow coordinators
  │   ├── services/                 # Shared services
  │   │   ├── api/                  # External API clients
  │   │   ├── database/             # DB config, loaders, schema
  │   │   └── document/             # Document builders, RAG
  │   ├── scheduler/                # Consolidated scheduler (merge rlc_scheduler)
  │   │   ├── agents/               # Scheduled task agents
  │   │   ├── tasks/                # Task definitions
  │   │   └── runner.py             # Main scheduler
  │   ├── tools/                    # LLM tools & utilities
  │   └── utils/                    # Config, helpers
  │
  ├── database/                     # Database artifacts
  │   ├── schemas/                  # SQL schema files (001-009)
  │   ├── migrations/               # Schema migrations
  │   ├── views/                    # SQL views
  │   └── queries/                  # Reusable queries
  │
  ├── config/                       # Configuration (single location)
  │   ├── data_sources.csv          # Master data source list
  │   ├── weather_locations.json
  │   └── schedules.json            # Task schedules
  │
  ├── data/                         # Runtime data (gitignored mostly)
  │   ├── raw/                      # Raw downloaded data
  │   ├── processed/                # Transformed data
  │   ├── cache/                    # API response cache
  │   └── exports/                  # PowerBI exports, CSVs
  │
  ├── output/                       # Generated outputs
  │   ├── reports/                  # Generated Word reports
  │   ├── visualizations/           # Chart images
  │   └── logs/                     # Application logs
  │
  ├── tests/                        # Test suite
  │   ├── unit/
  │   ├── integration/
  │   └── fixtures/
  │
  ├── docs/                         # Documentation
  │   ├── architecture/             # System design docs
  │   ├── setup/                    # Installation guides
  │   ├── api/                      # API documentation
  │   └── runbooks/                 # Operational guides
  │
  ├── domain_knowledge/             # Agricultural economist knowledge base
  │   ├── balance_sheets/           # Excel models (current Models/)
  │   │   ├── biofuels/
  │   │   ├── feed_grains/
  │   │   ├── food_grains/
  │   │   ├── oilseeds/
  │   │   └── fats_greases/
  │   ├── sample_reports/           # Reference reports (current report_samples/)
  │   ├── operator_guides/          # Silver Operators docs
  │   └── llm_context/              # LLM training context
  │
  ├── scripts/                      # Standalone utility scripts
  │   ├── data_ingestion/           # One-time data loads
  │   ├── maintenance/              # DB maintenance, cleanup
  │   └── deployment/               # Deploy scripts (merge deployment/)
  │
  ├── dashboards/                   # Visualization assets
  │   ├── powerbi/                  # PowerBI files
  │   └── templates/                # Dashboard templates
  │
  └── archive/                      # Historical/inactive items
      ├── presentations/            # Old conference presentations
      └── deprecated_code/          # Old implementations for reference
        """.strip()

    root = parse_tree(text)
    if not root:
        sys.exit("Failed to parse tree structure.")

    html = generate_html(root)
    with open(args.out, 'w', encoding='utf-8') as f:
        f.write(html)
    print(f"Visualization written to {args.out}")

if __name__ == "__main__":
    main()